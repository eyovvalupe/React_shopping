{"ast":null,"code":"/** @license React v16.6.0\n * react-cache.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n\n    var React = require('react');\n\n    var scheduler = require('scheduler');\n    /**\n     * Similar to invariant but only logs a warning if the condition is not met.\n     * This can be used to log issues in development environments in critical\n     * paths. Removing the logging code for production environments will keep the\n     * same logic and follow the same code paths.\n     */\n\n\n    var warningWithoutStack = function warningWithoutStack() {};\n\n    {\n      warningWithoutStack = function warningWithoutStack(condition, format) {\n        for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n          args[_key - 2] = arguments[_key];\n        }\n\n        if (format === undefined) {\n          throw new Error('`warningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');\n        }\n\n        if (args.length > 8) {\n          // Check before the condition to catch violations early.\n          throw new Error('warningWithoutStack() currently supports at most 8 arguments.');\n        }\n\n        if (condition) {\n          return;\n        }\n\n        if (typeof console !== 'undefined') {\n          var _args$map = args.map(function (item) {\n            return '' + item;\n          }),\n              a = _args$map[0],\n              b = _args$map[1],\n              c = _args$map[2],\n              d = _args$map[3],\n              e = _args$map[4],\n              f = _args$map[5],\n              g = _args$map[6],\n              h = _args$map[7];\n\n          var message = 'Warning: ' + format; // We intentionally don't use spread (or .apply) because it breaks IE9:\n          // https://github.com/facebook/react/issues/13610\n\n          switch (args.length) {\n            case 0:\n              console.error(message);\n              break;\n\n            case 1:\n              console.error(message, a);\n              break;\n\n            case 2:\n              console.error(message, a, b);\n              break;\n\n            case 3:\n              console.error(message, a, b, c);\n              break;\n\n            case 4:\n              console.error(message, a, b, c, d);\n              break;\n\n            case 5:\n              console.error(message, a, b, c, d, e);\n              break;\n\n            case 6:\n              console.error(message, a, b, c, d, e, f);\n              break;\n\n            case 7:\n              console.error(message, a, b, c, d, e, f, g);\n              break;\n\n            case 8:\n              console.error(message, a, b, c, d, e, f, g, h);\n              break;\n\n            default:\n              throw new Error('warningWithoutStack() currently supports at most 8 arguments.');\n          }\n        }\n\n        try {\n          // --- Welcome to debugging React ---\n          // This error was thrown as a convenience so that you can use this stack\n          // to find the callsite that caused this warning to fire.\n          var argIndex = 0;\n\n          var _message = 'Warning: ' + format.replace(/%s/g, function () {\n            return args[argIndex++];\n          });\n\n          throw new Error(_message);\n        } catch (x) {}\n      };\n    }\n    var warningWithoutStack$1 = warningWithoutStack;\n\n    function createLRU(limit) {\n      var LIMIT = limit; // Circular, doubly-linked list\n\n      var first = null;\n      var size = 0;\n      var cleanUpIsScheduled = false;\n\n      function scheduleCleanUp() {\n        if (cleanUpIsScheduled === false && size > LIMIT) {\n          // The cache size exceeds the limit. Schedule a callback to delete the\n          // least recently used entries.\n          cleanUpIsScheduled = true;\n          scheduler.unstable_scheduleCallback(cleanUp);\n        }\n      }\n\n      function cleanUp() {\n        cleanUpIsScheduled = false;\n        deleteLeastRecentlyUsedEntries(LIMIT);\n      }\n\n      function deleteLeastRecentlyUsedEntries(targetSize) {\n        // Delete entries from the cache, starting from the end of the list.\n        if (first !== null) {\n          var resolvedFirst = first;\n          var last = resolvedFirst.previous;\n\n          while (size > targetSize && last !== null) {\n            var _onDelete = last.onDelete;\n            var _previous = last.previous;\n            last.onDelete = null; // Remove from the list\n\n            last.previous = last.next = null;\n\n            if (last === first) {\n              // Reached the head of the list.\n              first = last = null;\n            } else {\n              first.previous = _previous;\n              _previous.next = first;\n              last = _previous;\n            }\n\n            size -= 1; // Call the destroy method after removing the entry from the list. If it\n            // throws, the rest of cache will not be deleted, but it will be in a\n            // valid state.\n\n            _onDelete();\n          }\n        }\n      }\n\n      function add(value, onDelete) {\n        var entry = {\n          value: value,\n          onDelete: onDelete,\n          next: null,\n          previous: null\n        };\n\n        if (first === null) {\n          entry.previous = entry.next = entry;\n          first = entry;\n        } else {\n          // Append to head\n          var last = first.previous;\n          last.next = entry;\n          entry.previous = last;\n          first.previous = entry;\n          entry.next = first;\n          first = entry;\n        }\n\n        size += 1;\n        return entry;\n      }\n\n      function update(entry, newValue) {\n        entry.value = newValue;\n      }\n\n      function access(entry) {\n        var next = entry.next;\n\n        if (next !== null) {\n          // Entry already cached\n          var resolvedFirst = first;\n\n          if (first !== entry) {\n            // Remove from current position\n            var _previous2 = entry.previous;\n            _previous2.next = next;\n            next.previous = _previous2; // Append to head\n\n            var last = resolvedFirst.previous;\n            last.next = entry;\n            entry.previous = last;\n            resolvedFirst.previous = entry;\n            entry.next = resolvedFirst;\n            first = entry;\n          }\n        } else {// Cannot access a deleted entry\n          // TODO: Error? Warning?\n        }\n\n        scheduleCleanUp();\n        return entry.value;\n      }\n\n      function setLimit(newLimit) {\n        LIMIT = newLimit;\n        scheduleCleanUp();\n      }\n\n      return {\n        add: add,\n        update: update,\n        access: access,\n        setLimit: setLimit\n      };\n    }\n\n    var Pending = 0;\n    var Resolved = 1;\n    var Rejected = 2;\n    var currentOwner = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;\n\n    function readContext(Context, observedBits) {\n      var dispatcher = currentOwner.currentDispatcher;\n\n      if (dispatcher === null) {\n        throw new Error('react-cache: read and preload may only be called from within a ' + \"component's render. They are not supported in event handlers or \" + 'lifecycle methods.');\n      }\n\n      return dispatcher.readContext(Context, observedBits);\n    }\n\n    function identityHashFn(input) {\n      {\n        !(typeof input === 'string' || typeof input === 'number' || typeof input === 'boolean' || input === undefined || input === null) ? warningWithoutStack$1(false, 'Invalid key type. Expected a string, number, symbol, or boolean, ' + 'but instead received: %s' + '\\n\\nTo use non-primitive values as keys, you must pass a hash ' + 'function as the second argument to createResource().', input) : void 0;\n      }\n      return input;\n    }\n\n    var CACHE_LIMIT = 500;\n    var lru = createLRU(CACHE_LIMIT);\n    var entries = new Map();\n    var CacheContext = React.createContext(null);\n\n    function accessResult(resource, fetch, input, key) {\n      var entriesForResource = entries.get(resource);\n\n      if (entriesForResource === undefined) {\n        entriesForResource = new Map();\n        entries.set(resource, entriesForResource);\n      }\n\n      var entry = entriesForResource.get(key);\n\n      if (entry === undefined) {\n        var thenable = fetch(input);\n        thenable.then(function (value) {\n          if (newResult.status === Pending) {\n            var resolvedResult = newResult;\n            resolvedResult.status = Resolved;\n            resolvedResult.value = value;\n          }\n        }, function (error) {\n          if (newResult.status === Pending) {\n            var rejectedResult = newResult;\n            rejectedResult.status = Rejected;\n            rejectedResult.value = error;\n          }\n        });\n        var newResult = {\n          status: Pending,\n          value: thenable\n        };\n        var newEntry = lru.add(newResult, deleteEntry.bind(null, resource, key));\n        entriesForResource.set(key, newEntry);\n        return newResult;\n      } else {\n        return lru.access(entry);\n      }\n    }\n\n    function deleteEntry(resource, key) {\n      var entriesForResource = entries.get(resource);\n\n      if (entriesForResource !== undefined) {\n        entriesForResource.delete(key);\n\n        if (entriesForResource.size === 0) {\n          entries.delete(resource);\n        }\n      }\n    }\n\n    function unstable_createResource(fetch, maybeHashInput) {\n      var hashInput = maybeHashInput !== undefined ? maybeHashInput : identityHashFn;\n      var resource = {\n        read: function read(input) {\n          // react-cache currently doesn't rely on context, but it may in the\n          // future, so we read anyway to prevent access outside of render.\n          readContext(CacheContext);\n          var key = hashInput(input);\n          var result = accessResult(resource, fetch, input, key);\n\n          switch (result.status) {\n            case Pending:\n              {\n                var suspender = result.value;\n                throw suspender;\n              }\n\n            case Resolved:\n              {\n                var _value = result.value;\n                return _value;\n              }\n\n            case Rejected:\n              {\n                var error = result.value;\n                throw error;\n              }\n\n            default:\n              // Should be unreachable\n              return undefined;\n          }\n        },\n        preload: function preload(input) {\n          // react-cache currently doesn't rely on context, but it may in the\n          // future, so we read anyway to prevent access outside of render.\n          readContext(CacheContext);\n          var key = hashInput(input);\n          accessResult(resource, fetch, input, key);\n        }\n      };\n      return resource;\n    }\n\n    function unstable_setGlobalCacheLimit(limit) {\n      lru.setLimit(limit);\n    }\n\n    exports.unstable_createResource = unstable_createResource;\n    exports.unstable_setGlobalCacheLimit = unstable_setGlobalCacheLimit;\n  })();\n}","map":null,"metadata":{},"sourceType":"script"}